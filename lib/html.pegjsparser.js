module.exports = (function(){
  /* Generated by PEG.js-fn @VERSION (http://pegjs.majda.cz/). */
  /* Functional modification by shaman.sir@gmail.com (http://shamansir.github.com/). */
  
  /* ########### ENVIRONMENT ########### */
  
  var input,
      options;
  
  var pos, // 0, parser position
      p_pos; // 0, previous parser position
  
  
  // This code encloses all of the user blocks (initializer and/or actions)
  // in their own sandbox, so if there is an initializer, its inner variables
  // will [only] be accessible to actions; this, however, requires an initializer
  // not to have any first-level return statements. Also, this approach keeps parser
  // inner variables safe from user access, except the ones defined above.
  var __p_blocks = (function() { return function() {
    
    // backwards compatibility with original peg-js
    function offset() { return p_pos; };
    function text() { return input.substring(p_pos, pos); };
    
    /* ########### USER CODE ########### */
    
    
    /* ----------- INITIALIZER ----------- */
    
        var DomNodes = require('./domnodes');
    
    
    /* ----------- BLOCKS ----------- */
    
    // Blocks are grouped by rule name and id; they all get access to current context
    // through č variable which they expand into their arguments. Arguments
    // names are precalculated during parser generation process.
    
    // ƒ and č variables are named so creepy just to ensure that parser writer will not use them
    // for naming variables in his code (only č may clash in this architecture, in fact),
    // we hope any modern environment supports Unicode now
    
    return {
      "Content": [
        function(č) {
          // Content[0]
          return (function(nodes) {
            
                return new DomNodes.DocumentNode({
                    childNodes: nodes
                });
            
          })(č.nodes);
        }
      ],
      "DocType": [
        function(č) {
          // DocType[0]
          return (function(doctype) {
            
                return new DomNodes.Doctype({ data: doctype.join('')});
            
          })(č.doctype);
        }
      ],
      "Comment": [
        function(č) {
          // Comment[0]
          return (function(c) {
            return c
          })(č.c);
        },
        function(č) {
          // Comment[1]
          return (function(c) {
            
                return new DomNodes.Comment({ data: c.join('') });
            
          })(č.c);
        }
      ],
      "Script": [
        function(č) {
          // Script[0]
          return (function(attributes,c) {
            return c
          })(č.attributes,č.c);
        },
        function(č) {
          // Script[1]
          return (function(attributes,c) {
            
                return new DomNodes.Tag({
                    name: 'script',
                    attributes: attributes,
                    data: c.join('')
                });
            
          })(č.attributes,č.c);
        }
      ],
      "Style": [
        function(č) {
          // Style[0]
          return (function(attributes,c) {
            return c
          })(č.attributes,č.c);
        },
        function(č) {
          // Style[1]
          return (function(attributes,c) {
            
                return new DomNodes.Tag({
                    name: 'style',
                    attributes: attributes,
                    data: c.join('')
                });
            
          })(č.attributes,č.c);
        }
      ],
      "BalancedTag": [
        function(č) {
          // BalancedTag[0]
          return (function(startTag,childs,endTag) {
            
                if (startTag.name != endTag) {
                    throw new Error("Expected </" + startTag.name + "> but </" + endTag + "> found. (" + line() + ":" + column() + ")");
                }
             
                return new DomNodes.Tag({
                    name: startTag.name,
                    attributes: startTag.attributes,
                    childNodes: childs
                });
              
          })(č.startTag,č.childs,č.endTag);
        }
      ],
      "SelfClosingTag": [
        function(č) {
          // SelfClosingTag[0]
          return (function(name,attributes) {
            
                return new DomNodes.Tag({
                    name: name,
                    attributes: attributes,
                    childNodes: []
                });
            
          })(č.name,č.attributes);
        }
      ],
      "StartTag": [
        function(č) {
          // StartTag[0]
          return (function(name,attributes) {
            
              return { 
                name: name,
                attributes: attributes
              }
            
          })(č.name,č.attributes);
        }
      ],
      "EndTag": [
        function(č) {
          // EndTag[0]
          return (function(name) {
             return name; 
          })(č.name);
        }
      ],
      "Attribute": [
        function(č) {
          // Attribute[0]
          return (function(attribute) {
            
                return attribute;
            
          })(č.attribute);
        }
      ],
      "ValuedAttribute": [
        function(č) {
          // ValuedAttribute[0]
          return (function(name,value) {
            
              return {
                name: name,
                value: value
              };
            
          })(č.name,č.value);
        }
      ],
      "ValuelessAttribute": [
        function(č) {
          // ValuelessAttribute[0]
          return (function(name) {
            
              return {
                name: name,
                value: null
              };
            
          })(č.name);
        }
      ],
      "AttributeName": [
        function(č) {
          // AttributeName[0]
          return (function(chars) {
             return chars.join(''); 
          })(č.chars);
        }
      ],
      "QuotedAttributeValue": [
        function(č) {
          // QuotedAttributeValue[0]
          return (function(value) {
             return value; 
          })(č.value);
        }
      ],
      "UnquotedAttributeValue": [
        function(č) {
          // UnquotedAttributeValue[0]
          return (function(value) {
             return value.join(''); 
          })(č.value);
        }
      ],
      "TagName": [
        function(č) {
          // TagName[0]
          return (function(chars) {
             return chars.join(''); 
          })(č.chars);
        }
      ],
      "Text": [
        function(č) {
          // Text[0]
          return (function(chars) {
            
                return new DomNodes.Text({
                    data: chars.join('')
                });
            
          })(č.chars);
        }
      ],
      "QuotedString": [
        function(č) {
          // QuotedString[0]
          return (function(d) {
            
                    return d.join('');
                
          })(č.d);
        },
        function(č) {
          // QuotedString[1]
          return (function(d) {
            
                    return d.join('');
                
          })(č.d);
        }
      ],
      "stringData": [
        function(č) {
          // stringData[0]
          return (function(c) {
             c 
          })(č.c);
        }
      ]
    };
    
  } })();
  
  // ƒ and č variables are named so creepy just to ensure that parser writer will not use them
  // for naming variables in his code (only č may clash in this architecture, in fact),
  // we hope any modern environment supports Unicode now
  var ƒ = null; // holds a pointer to current rule blocks, will be initialized in parse() function
  
  /* ########### PARSER ########### */
  
  var __parser = function() {
    
  /* =========== PARSER-DEPENDENT CODE =========== */
    
    /* ----------- RULES DEFINITIONS ----------- */
    
    var rules = {}; (function() {
    
    rules.Content = function() {
      var _code = ƒ.Content;
      return (
        action(
          label("nodes",
            ref(rules.Nodes)
          ),
          _code[0])
          /*{
              return new DomNodes.DocumentNode({
                  childNodes: nodes
              });
          }*/
      ());
    }
    
    rules.Nodes = function() {
      return (
        any(
          choice(
            ref(rules.DocType),
            ref(rules.Comment),
            ref(rules.Script),
            ref(rules.SelfClosingTag),
            ref(rules.BalancedTag),
            ref(rules.Text)
          )
        )
      ());
    }
    
    rules.DocType = function() {
      var _code = ƒ.DocType;
      return (
        action(
          seqnc(
            re(/<!doctype/i, quote("<!doctype")),
            label("doctype",
              any(
                re(/^[^>]/, "[^>]")
              )
            ),
            match(">")
          ),
          _code[0])
          /*{
              return new DomNodes.Doctype({ data: doctype.join('')});
          }*/
      ());
    }
    
    rules.Comment = function() {
      var _code = ƒ.Comment;
      return (
        action(
          seqnc(
            match("<!--"),
            label("c",
              any(
                action(
                  seqnc(
                    not(
                      match("-->")
                    ),
                    label("c",
                      ch()
                    )
                  ),
                  _code[0])
                  /*{return c}*/
              )
            ),
            match("-->")
          ),
          _code[1])
          /*{
              return new DomNodes.Comment({ data: c.join('') });
          }*/
      ());
    }
    
    rules.Script = function() {
      var _code = ƒ.Script;
      return (
        action(
          seqnc(
            re(/<script/i, quote("<script")),
            label("attributes",
              any(
                ref(rules.Attribute)
              )
            ),
            any(
              match(" ")
            ),
            match(">"),
            label("c",
              any(
                action(
                  seqnc(
                    not(
                      match("</script>")
                    ),
                    label("c",
                      ch()
                    )
                  ),
                  _code[0])
                  /*{return c}*/
              )
            ),
            match("</script>")
          ),
          _code[1])
          /*{
              return new DomNodes.Tag({
                  name: 'script',
                  attributes: attributes,
                  data: c.join('')
              });
          }*/
      ());
    }
    
    rules.Style = function() {
      var _code = ƒ.Style;
      return (
        action(
          seqnc(
            re(/<style/i, quote("<style")),
            label("attributes",
              any(
                ref(rules.Attribute)
              )
            ),
            any(
              match(" ")
            ),
            match(">"),
            label("c",
              any(
                action(
                  seqnc(
                    not(
                      match("</style>")
                    ),
                    label("c",
                      ch()
                    )
                  ),
                  _code[0])
                  /*{return c}*/
              )
            ),
            match("</style>")
          ),
          _code[1])
          /*{
              return new DomNodes.Tag({
                  name: 'style',
                  attributes: attributes,
                  data: c.join('')
              });
          }*/
      ());
    }
    
    rules.BalancedTag = function() {
      var _code = ƒ.BalancedTag;
      return (
        action(
          seqnc(
            label("startTag",
              ref(rules.StartTag)
            ),
            label("childs",
              ref(rules.Nodes)
            ),
            label("endTag",
              ref(rules.EndTag)
            )
          ),
          _code[0])
          /*{
              if (startTag.name != endTag) {
                  throw new Error("Expected </" + startTag.name + "> but </" + endTag + "> found. (" + line() + ":" + column() + ")");
              }
           
              return new DomNodes.Tag({
                  name: startTag.name,
                  attributes: startTag.attributes,
                  childNodes: childs
              });
            }*/
      ());
    }
    
    rules.SelfClosingTag = function() {
      var _code = ƒ.SelfClosingTag;
      return (
        action(
          seqnc(
            match("<"),
            label("name",
              ref(rules.TagName)
            ),
            label("attributes",
              any(
                ref(rules.Attribute)
              )
            ),
            any(
              match(" ")
            ),
            match("/>")
          ),
          _code[0])
          /*{
              return new DomNodes.Tag({
                  name: name,
                  attributes: attributes,
                  childNodes: []
              });
          }*/
      ());
    }
    
    rules.StartTag = function() {
      var _code = ƒ.StartTag;
      return (
        action(
          seqnc(
            match("<"),
            label("name",
              ref(rules.TagName)
            ),
            label("attributes",
              any(
                ref(rules.Attribute)
              )
            ),
            any(
              match(" ")
            ),
            match(">")
          ),
          _code[0])
          /*{
            return { 
              name: name,
              attributes: attributes
            }
          }*/
      ());
    }
    
    rules.EndTag = function() {
      var _code = ƒ.EndTag;
      return (
        action(
          seqnc(
            match("</"),
            label("name",
              ref(rules.TagName)
            ),
            match(">")
          ),
          _code[0])
          /*{ return name; }*/
      ());
    }
    
    rules.Attribute = function() {
      var _code = ƒ.Attribute;
      return (
        action(
          seqnc(
            any(
              match(" ")
            ),
            label("attribute",
              choice(
                ref(rules.ValuedAttribute),
                ref(rules.ValuelessAttribute)
              )
            )
          ),
          _code[0])
          /*{
              return attribute;
          }*/
      ());
    }
    
    rules.ValuedAttribute = function() {
      var _code = ƒ.ValuedAttribute;
      return (
        action(
          seqnc(
            label("name",
              ref(rules.AttributeName)
            ),
            match("="),
            label("value",
              ref(rules.AttributeValue)
            )
          ),
          _code[0])
          /*{
            return {
              name: name,
              value: value
            };
          }*/
      ());
    }
    
    rules.ValuelessAttribute = function() {
      var _code = ƒ.ValuelessAttribute;
      return (
        action(
          label("name",
            ref(rules.AttributeName)
          ),
          _code[0])
          /*{
            return {
              name: name,
              value: null
            };
          }*/
      ());
    }
    
    rules.AttributeName = function() {
      var _code = ƒ.AttributeName;
      return (
        action(
          label("chars",
            some(
              re(/^[a-zA-Z0-9\-:]/, "[a-zA-Z0-9\\-:]")
            )
          ),
          _code[0])
          /*{ return chars.join(''); }*/
      ());
    }
    
    rules.AttributeValue = function() {
      return (
        choice(
          ref(rules.QuotedAttributeValue),
          ref(rules.UnquotedAttributeValue)
        )
      ());
    }
    
    rules.QuotedAttributeValue = function() {
      var _code = ƒ.QuotedAttributeValue;
      return (
        action(
          label("value",
            ref(rules.QuotedString)
          ),
          _code[0])
          /*{ return value; }*/
      ());
    }
    
    rules.UnquotedAttributeValue = function() {
      var _code = ƒ.UnquotedAttributeValue;
      return (
        action(
          label("value",
            any(
              ref(rules.decimalDigit)
            )
          ),
          _code[0])
          /*{ return value.join(''); }*/
      ());
    }
    
    rules.TagName = function() {
      var _code = ƒ.TagName;
      return (
        action(
          label("chars",
            some(
              re(/^[a-zA-Z0-9]/, "[a-zA-Z0-9]")
            )
          ),
          _code[0])
          /*{ return chars.join(''); }*/
      ());
    }
    
    rules.Text = function() {
      var _code = ƒ.Text;
      return (
        action(
          label("chars",
            some(
              re(/^[^<]/, "[^<]")
            )
          ),
          _code[0])
          /*{
              return new DomNodes.Text({
                  data: chars.join('')
              });
          }*/
      ());
    }
    
    rules.decimalDigit = function() {
      return (
        re(/^[0-9]/, "[0-9]")
      ());
    }
    
    rules.QuotedString = function() {
      var _code = ƒ.QuotedString;
      return (
        choice(
          action(
            seqnc(
              match("\""),
              label("d",
                any(
                  choice(
                    ref(rules.stringData),
                    match("'")
                  )
                )
              ),
              match("\"")
            ),
            _code[0])
            /*{
                    return d.join('');
                }*/,
          action(
            seqnc(
              match("'"),
              label("d",
                any(
                  choice(
                    ref(rules.stringData),
                    match("\"")
                  )
                )
              ),
              match("'")
            ),
            _code[1])
            /*{
                    return d.join('');
                }*/
        )
      ());
    }
    
    rules.stringData = function() {
      var _code = ƒ.stringData;
      return (
        choice(
          re(/^[^"'\\]/, "[^\"'\\\\]"),
          action(
            seqnc(
              match("\\"),
              label("c",
                ch()
              )
            ),
            _code[0])
            /*{ c }*/
        )
      ());
    }
    
    })();
    
    /* ----------- OPERATORS ----------- */
    
    // get current char
    function cc() { return (pos < ilen) ? input.charAt(pos) : EOI; }
    
    var ref = def(inctx); // will call rule inside context
    
    function action(f, code) {
      return inctx(function() {
        p_pos = pos; var res; // save previous position
        f(); res = code(cctx);
        if (res === null) { pos = p_pos;
           failed(SOMETHING, NOTHING); }
        return res;
      });
    }
    action = def(action);
    
    function seqnc(/*f...*/) {
      var p_pos = pos; // save previous position locally
      var fs = arguments,
          s = [],
          on_miss = function(e) {
                        pos = p_pos; throw e; };
      for (var fi = 0, fl = fs.length;
           fi < fl; fi++) {
        s.push(safe(fs[fi], on_miss));
      }
      return s;
    }
    seqnc = def(seqnc);
    
    function choice(/*f...*/) {
      var fs = arguments,
          missed = 0,
          my_e = null,
          on_miss = function(e) {
            my_e = e; missed = 1;
          };
      for (var fi = 0, fl = fs.length;
           fi < fl; fi++) {
        var res = safe(fs[fi], on_miss);
        if (!missed) return res;
        missed = 0;
      }
      throw my_e;
    }
    choice = def(choice);
    
    function match(str) {
      var slen = str.length;
      if ((pos + slen) > ilen) {
        failed(quote(str), EOI); // exits
      }
      if (input.substr(pos, slen) === str) {
        pos += slen;
        return str;
      }
      failed(quote(str), cc());
    }
    match = def(match);
    
    function label(lbl, f) {
      return cctx[lbl] = f();
    }
    label = def(label);
    
    function some(f) {
      return [f()].concat(any(f)());
    }
    some = def(some);
    
    function any(f) {
      var s = [],
          missed = 0,
          on_miss = function() { missed = 1; };
      while (!missed) {
        s.push(safe(f, on_miss));
      }
      if (missed) s.splice(-1);
      return s;
    }
    any = def(any);
    
    function not(f) {
      // save previous position locally
      var p_pos = pos, missed = 0;
      nr = 1; safe(f, function() {
        missed = 1;
      }); nr = 0;
      pos = p_pos;
      if (missed) return '';
      failed(EOI, cc());
    }
    not = def(not);
    
    function re(rx, desc) {
      var res, desc = desc || rx.source;
      if (res = rx.exec(input.substr(pos))) {
         if (res.index !== 0) failed(desc, cc());
         pos += res[0].length;
         return res[0];
      } else failed(desc, cc());
    }
    re = def(re);
    
    function ch() { // char
      if (pos >= ilen) failed(ANY, EOI);
      return input[pos++];
    }
    ch = def(ch);
    
  /* =========== PARSER-INDEPENDENT CODE =========== */
    
    /* ----------- VARIABLES ----------- */
    
    var cache, // {}, rule results cache, by name/pos
        ctx, // { ... }, total context
        cctx, // { ... }, current context pointer
        ctxl, // -1, context level
        current, // '-', current rule name
        alias; // '', current rule alias, if defined
    
    var failures, // {}, failures data
        rmfpos, // 0, rightmost failure position
        nr; // 0, no-report, fire errors w/o reporting
    
    var /*input, */ilen; // input, input length
    
    /* ----------- CONTEXT ----------- */
    
    function ctx_lvl(parent) {
      function CtxLevel() {
          this.__p = parent;
          this.__l = ++ctxl;
          this.__c = null;
      };
      CtxLevel.prototype = parent;
      return new CtxLevel();
    }
    
    function din() {  // dive in
      if (!cctx.__c) cctx.__c = ctx_lvl(cctx);
      cctx = cctx.__c;
    }
    function dout() { // dive out
      if (!cctx.__p) throw new Error('reached top context level');
      cctx = cctx.__p; --ctxl;
    }
    function inctx(f) { // execute in own context and return
      var r, e;
      din(); r = safe(f, function(err) { e = err; });
      dout(); if (e) throw e;
      return r;
    }
    
    /* ----------- DEFERRED ----------- */
    // Makes passed function to save its argument values,
    // but not execute until specially requested
    
    function def(f) {
      return function() {
        return (function(f, args) {
          return function() { return f.apply(null, args); };
        })(f, arguments);
      }
    }
    
    /* ----------- RULES WRAPPER ----------- */
    
    var ckey; // cache key
    for (var rule in rules) {
      rules[rule] = (function(name, rule) {
        return function() { current = name; return rule(); };
      })(rule, rules[rule]);
    }
    
    /* ----------- RESULT OBJECT + PARSE FUNCTION ----------- */
    
    var result = {
      /*
       * Parses the input with a generated parser. If the parsing is successfull,
       * returns a value explicitly or implicitly specified by the grammar from
       * which the parser was generated (see |PEG.buildParser|). If the parsing is
       * unsuccessful, throws |PEG.parser.MatchFailed| describing the error.
       */
      parse: function(_input, _opts) {
        var _opts = _opts || {};
        
        // initialize variables
        pos = 0, p_pos = 0, input = _input, options = _opts;
        
        ilen = input.length, failures = {}, rmfpos = 0, nr = 0;
        
        cache = {};
        ctxl = -1; ctx = ctx_lvl(), cctx = ctx;
        current = '-';
        
        var startRule = _opts.startRule || "Content";
        if (["Content"].indexOf(startRule) < 0) {
          throw new Error("Can't start parsing from rule " + quote(startRule) + ".");
        }
        
        // call user initializer and also
        // get blocks lying in the same context
        ƒ = __p_blocks();
        
        // find start rule
        if (startRule) {
          if (rules[startRule] === undefined) {
            throw new SyntaxError("Rule not found: " + quote(startRule) + ".");
          };
        } else {
          throw new Error("Start rule is not defined in options, no 'start' rule found and first rule in grammar was empty");
        }
        
        // and execute it
        var res;
        try {
          res = rules[startRule]();
          if ((pos < ilen) || 
              (res === null)) failed(EOI, cc());
        } catch(e) {
          if (e instanceof MatchFailed) {
            // throw rightmost error instead
            throw adapt(failures[rmfpos]);
          }
          throw e;
        }
        
        return res;
      },
      
      
      /* makes error type accessible outside */
      MatchFailed: MatchFailed,
      SyntaxError: SyntaxError
    };
    
    /* ----------- UTILS ----------- */
    
    function Marker(human_str) { this.str=human_str; };
    Marker.prototype.toString = function() { return this.str; };
    var EOI = new Marker('end of input'),
        ANY = new Marker('any character'),
        SOMETHING = new Marker('progress'),
        NOTHING = new Marker('nothing');
    
    function hexOf(ch) {
      var x = ch.charCodeAt(0),
          v = x.toString(16).toUpperCase(),
          h = (x > 0xFF),
          i = (h ? 4 : 2) - v.length;
      while (i--) v = v + '0';
      return '\\' + (h ? 'u' : 'x') + v;
    }
    
    function quote(s) {
      /*
       * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
       * string literal except for the closing quote character, backslash,
       * carriage return, line separator, paragraph separator, and line feed.
       * Any character may appear in the form of an escape sequence.
       *
       * For portability, we also escape escape all control and non-ASCII
       * characters. Note that "\0" and "\v" escape sequences are not used
       * because JSHint does not like the first and IE the second.
       */
      return '"' + s
        .replace(/\\/g, '\\\\')  // backslash
        .replace(/"/g, '\\"')    // closing quote character
        .replace(/\x08/g, '\\b') // backspace
        .replace(/\t/g, '\\t')   // horizontal tab
        .replace(/\n/g, '\\n')   // line feed
        .replace(/\f/g, '\\f')   // form feed
        .replace(/\r/g, '\\r')   // carriage return
        .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, hexOf)
        + '"';
    }
    
    /* ----------- FAILURES ----------- */
    
    function MatchFailed(what, found, expected) {
      this.what = what;
      this.expected = expected || [];
      this.found = found;
      this.offset = pos;
      this.xpos = [-1, -1];
      this.line = -1;
      this.column = -1;
    }
    MatchFailed.prototype = new Error();
    MatchFailed.prototype.toString = 
       function() { return 'MatchFailed: '+emsg(this); };
    var merr = function(fnd, exp) {
      return new MatchFailed(alias || current, fnd, exp);
    };
    
    function failed(expected, found) {
      var expected = alias || expected;
      // if no report required, just throw
      if (nr) throw merr(found, [expected]);
      if (pos > rmfpos) rmfpos = pos;
      var e = failures[pos] ||
             (failures[pos] = merr(found));
      /*if (e.found !== found)*/ e.found = found;
      var prev = e.expected;
      var f; for (var i = prev.length; i--;) {
        if (prev[i] === expected) {
          f = 1; break;
        }
      }; if (!f) prev.push(expected);
      throw e;
    }
    
    function safe(f, callback) {
      try { return f();
      } catch(e) {
        if (e instanceof MatchFailed) {
          if (callback) callback(e);
        } else { throw e; }
      }
    }
    
    function emsg(e) {
      var found_str, exp_str;
      if (e.found instanceof Marker) {
        found_str = e.found.str;
      } else {
        found_str = quote(e.found);
      }
      if (e.expected instanceof Marker) {
        exp_str = e.expected.str;
      } else if ((e.expected.length === 1) &&
          (e.expected[0] instanceof Marker)) {
        exp_str = e.expected[0].str;
      } else {
        var xs = e.expected;
        exp_str = ((xs.length > 1)
                  ? (xs.slice(0,-1).join(', ')+' '+
                    'or '+xs.slice(-1))
                  : xs[0]);
      }
      return /*'Stopped at '+quote(e.what)+': */'Expected '+exp_str+
             ' but '+found_str+' found.';
    }
    function adapt(e) {
      e.message = emsg(e);
      if ((e.found instanceof Marker) && (e.found === EOI)) e.found = null;
      var xs = e.expected.sort();
      if ((xs.length === 1) &&
          (xs[0] === EOI)) {
        e.expected = [];
      }
      for (var i = xs.length; i--;)
        { if (xs[i] instanceof Marker) xs[i] = xs[i].str; };
      return e;
    }
    
    function SyntaxError(msg) { // may be thrown from parser
      this.message = msg;
    }
    SyntaxError.prototype = new Error();
    SyntaxError.prototype.toString = 
       function() { return 'SyntaxError: '+this.message; };
    
    /* ---------- RETURN RESULT OBJECT ----------- */
    
    return result;
    
  };
  
  
  /* ----------- RETURN PARSER ----------- */
  return __parser();
  
})();;